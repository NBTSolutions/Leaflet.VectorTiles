/**
 * @class FontCanvas
 * @inherits Canvas
 * @aka L.FontCanvas
 * A canvas renderer that can draw icon fonts
 */

L.FontCanvas = L.Canvas.extend({
  _updateCircle: function (layer) {
    if (!this._drawing || layer._empty()) { return; }

    var p = layer._point,
        ctx = this._ctx,
        r = layer._radius,
        s = (layer._radiusY || r) / r;

    this._drawnLayers[layer._leaflet_id] = layer;

    if (layer.options.content && layer.options.font) {
      ctx.font = layer.options.font;
      ctx.fillStyle = layer.options.color;
      ctx.fillText(layer.options.content, p.x, p.y);
    } else {
      if (s !== 1) {
        ctx.save();
        ctx.scale(1, s);
      }
      ctx.beginPath();
      ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

      if (s !== 1) {
        ctx.restore();
      }

      this._fillStroke(ctx, layer);
    }
  }
});


/**
 * @class VectorTiles
 * @inherits GridLayer
 * @aka L.VectorTiles
 * Manages interactive tiles of data
 *
 * @example
 * ```js
 * var vtLayer = new L.VectorTiles('http://mytiles.com/{z}/{x}/{y}.pbf', {
 *   map: map,
 *   debug: true
 * }).addTo(map);
 * ```
 */

L.VectorTiles = L.GridLayer.extend({

  /**
   *
   */
  style: {},

  /**
   *
   */
  initialize(url, options) {
    L.Util.setOptions(options);
    L.GridLayer.prototype.initialize.call(this, options);

    this._url = url;

    // TODO: figure out how to do without this
    this._map = options.map;

    // the FeatureGroup that holds per tile FeatureGroups
    this._featureGroup = L.featureGroup()
      .addTo(this._map);

    // show tile boundaries
    this._debug = options.debug;

    // pointers to individual layers
    // this._vectorTiles = {
    //   <tileKey>: {
    //     loaded: <Boolean>,
    //     features: {
    //       <featureId>: {
    //         geojson: <GeoJSON feature>,
    //         layer: <Leaflet layer>
    //       }
    //     },
    //     featureGroup: <L.FeatureGroup>
    //   }
    // }
    this._vectorTiles = {};

    // property based style modifications
    // for highlighting and junk
    // this._propertyStyles = {
    //   propertyName: {
    //     value1: { L.Path style options }
    //   }
    // }
    this._propertyStyles = {};

    // property based toggling
    this._propertyOnMap = {};

    //
    this._featureStyles = {};

    //
    this._featureOnMap = {};

    // mark a tile as loaded
    // this is needed because if a tile is unloaded before its finished loading
    // we need to wait for it to finish loading before we can clean up
    this.on('tileload', function(e) {
      var tileKey = this._tileCoordsToKey(e.coords);
      this._vectorTiles[tileKey].loaded = true;
    });

    // listen for tileunload event and clean up old features
    this.on('tileunload', function(e) {
      var tileKey = this._tileCoordsToKey(e.coords);

      // this is done here instead of in this.destroyTile because
      // we don't want the map to keep rendering features that are
      // no longer visible (which happens when tileunload fires before tileload)
      //this._featureGroup.removeLayer(this._vectorTiles[tileKey].featureGroup);

      // if the tile hasn't loaded yet wait until it loads to destroy it
      if (!(tileKey in this._vectorTiles) || !this._vectorTiles[tileKey].loaded) {
        this.on('tileload', function(e) {
          if (tileKey === this._tileCoordsToKey(e.coords)) {
            this.destroyTile(e.coords);
          }
        }.bind(this));
      } else {
        this.destroyTile(e.coords);
      }
    });
  },

  /**
   * This method laoads all features in a tile into an r-tree
   * This method is called after a tile is finished loading so that inserting
   * a feature into the tree is done once in bulk
   * Features in the tree have an id property generated by the `getFeatureId`
   * function to enable removing features from the tree
   */
  _bulkInsertTileIntoIndex(coords) {
    var tileKey = this._tileCoordsToKey(coords);

    this._vectorTiles[tileKey].index = rbush();

    var features = this._vectorTiles[tileKey].features;
    var bboxes = [];
    for (var id in features) {
      var geojson = features[id].geojson;
      var geom = geojson.geometry;
      var c = geojson.geometry.coordinates;

      var minX, minY, maxX, maxY;

      if (geom.type === 'Point') {
        minX = maxX = c[0];
        minY = maxY = c[1];
      } else {
        var bbox = turf.bbox(geom);
        minX = bbox[0];
        minY = bbox[1];
        maxX = bbox[2];
        maxY = bbox[3];
      }

      bboxes.push({
        minX: minX,
        minY: minY,
        maxX: maxX,
        maxY: maxY,
        id: this.options.getFeatureId(geojson),
      });
    }

    // bulk load all the features for this tile
    this._vectorTiles[tileKey].index.load(bboxes);
  },

  /**
   * @method search(min: L.LatLng, max: L.LatLng): Array<String>
   * returns an array of feature ids near a given point
   */
  search(min, max) {
    var results = [];

    for (var tileKey in this._vectorTiles) {
      var tree = this._vectorTiles[tileKey].index;
      if (!tree)
        continue; // index may not be built yet

      var minX = min.lng;
      var minY = min.lat;
      var maxX = max.lng;
      var maxY = max.lat;
      results = results.concat(tree.search({ minX, minY, maxX, maxY }).map(r => r.id));
    }

    return results;
  },

  /**
   *
   */
  destroyTile(coords) {
    var tileKey = this._tileCoordsToKey(coords);

    // remove this tile's FeatureGroup from the map
    this._featureGroup.removeLayer(this._vectorTiles[tileKey].featureGroup);

    // delete the tile's data
    delete this._vectorTiles[tileKey];
  },

  /**
   * This method:
   *   - fetches the data for the tile
   *   - adds all of its features to the map
   *   - adds its features to the internal data structure
   *   - inserts its features into the a spatial tree
   */
  createTile: function(coords, done) {
    var tile = L.DomUtil.create('div', 'leaflet-tile');
    if (this.options.debug) {
      // show tile boundaries
      tile.style.outline = '1px solid red';
    }
    var tileKey = this._tileCoordsToKey(coords);
    var featureGroup = L.featureGroup();
    this._vectorTiles[tileKey] = {
      features: {},
      featureGroup: featureGroup
    };

    var n = 0;

    var start = Date.now();

    // fetch vector tile data for this tile
    var url = L.Util.template(this._url, coords);
    fetch(url)
      .then(res => res.json())
      .then(layers => {
        for (var i = 0; i < layers.length; i++) {
          for (var j = 0; j < layers[i].features.features.length; j++) {
            n++;
            var geojson = layers[i].features.features[j];
            var id = this.options.getFeatureId(geojson);
            var layer = this._geojsonToLayer(geojson, id);
            if (!layer) {
              // unsupported geometry type
              continue;
            }
            this._vectorTiles[tileKey].features[id] = {
              geojson: geojson,
              layer: layer
            };

            var style = {};
            var onMap = true;

            // property based styles
            for (prop in geojson.properties) {
              // apply style from options
              if (prop in this.options.style
                  && geojson.properties[prop] in this.options.style[prop]) {
                Object.assign(style, this.options.style[prop][geojson.properties[prop]]);
              }

              // apply style modifications
              if (prop in this._propertyStyles
                  && geojson.properties[prop] in this._propertyStyles[prop]) {
                Object.assign(style, this._propertyStyles[prop][geojson.properties[prop]]);
              }

              // put on map based on property
              if (prop in this._propertyOnMap
                  && geojson.properties[prop] in this._propertyOnMap[prop]) {
                onMap = this._propertyOnMap[prop][geojson.properties[prop]];
              }
            }

            // feature based styles
            if (id in this._featureStyles) {
              Object.assign(style, this._featureStyles[id]);
            }

            layer.setStyle(style);

            // feature based on map
            if (id in this._featureOnMap) {
              onMap = this._featureOnMap[id];
            }

            if (onMap)
              featureGroup.addLayer(layer);
          }
        }

        // load new features into spatial index
        this._bulkInsertTileIntoIndex(coords);

        // add the featureGroup of this tile to the map
        featureGroup.addTo(this._featureGroup);

        done(null, tile);
      });

    return tile;
  },

  /**
   * @method hideByProperty(property: String, value: String): this
   * Removes features from the map by property
   * Wrapper function of _toggleByProperty
   *   equivalent to this._toggleByProperty(property, value, false);
   */
  hideByProperty(property, value) {
    this._toggleByProperty(property, value, false);
    return this;
  },

  /**
   * @method showByProperty(property: String, value: String): this
   * Add features to the map by property
   * Wrapper function of _toggleByProperty
   *   equivalent to this._toggleByProperty(property, value, true);
   */
  showByProperty(property, value) {
    this._toggleByProperty(property, value, true);
    return this;
  },

  /**
   * Iterates over all features and add them to or removes them from
   * the map based on a property value
   */
  _toggleByProperty(property, value, on) {
    if (!(property in this._propertyOnMap)) {
      this._propertyOnMap[property] = {};
    }

    this._propertyOnMap[property][value] = on;

    // iterate over all features and toggle as needed
    for (var tileKey in this._vectorTiles) {
      var features = this._vectorTiles[tileKey].features;
      var featureGroup = this._vectorTiles[tileKey].featureGroup;
      for (var id in features) {
        var feature = features[id];
        if (property in feature.geojson.properties
            && feature.geojson.properties[property] === value) {
          if (on)
            featureGroup.addLayer(feature.layer);
          else
            featureGroup.removeLayer(feature.layer);
        }
      }
    }
  },

  /**
   * @method restyleByProperty(property: String, value: String, style: Object): this
   * Change the style of features based on property values
   */
  restyleByProperty(property, value, style) {
    if (!(property in this._propertyStyles)) {
      this._propertyStyles[property] = {};
    }

    if (!(value in this._propertyStyles[property])) {
      this._propertyStyles[property][value] = {};
    }

    Object.assign(this._propertyStyles[property][value], style);

    for (var tileKey in this._vectorTiles) {
      var features = this._vectorTiles[tileKey].features;
      for (var id in features) {
        var feature = features[id];
        if (property in feature.geojson.properties
            && feature.geojson.properties[property] === value) {
          feature.layer.setStyle(style);
        }
      }
    }
    return this;
  },

  /**
   * @method setFeatureStyle(id: String, style: Object): this
   * Change the style of a feature by its id
   */
  setFeatureStyle(id, style) {
    this._featureStyles[id] = style;
    for (var tileKey in this._vectorTiles) {
      var features = this._vectorTiles[tileKey].features;
      if (id in features) {
        var layer = features[id].layer;
        layer.setStyle(style);
      }
    }
    return this;
  },

  /**
   * Revert a feature to its origin style
   * TODO
   */
  resetFeatureStyle(id) {
    delete this._featureStyles[id];
    for (var tileKey in this._vectorTiles) {
      var features = this._vectorTiles[tileKey].features;
      if (id in features) {
        var layer = features[id].layer;
        // layer.resetStyle();
      }
    }
  },

  /**
   * @method getFeatureGroup(): L.FeatureGroup
   * Returns the feature group that holds all features in the GridLayer
   * intended for use with Leaflet.Draw
   */
  getFeatureGroup() {
    return this._featureGroup;
  },

  /**
   * Convert a GeoJSON feature into a Leaflet feature
   * Point -> L.Circle
   * LineString -> L.Polyline
   * Polygon/Multipolygon -> L.Polygon
   */
  _geojsonToLayer(feature, id) {
    var layer;
    switch (feature.geometry.type) {
      case 'Point':
        var coords = feature.geometry.coordinates;
        layer = L.circle([coords[1], coords[0]], {
          radius: 40
        });
        break;

      case 'LineString':
        var coords = feature.geometry.coordinates.map(c => [c[1], c[0]]);
        layer = L.polyline(coords, {});
        break;

      case 'Polygon':
      case 'MultiPolygon':
        var coords = feature.geometry.coordinates.map(ring => ring.map(c => [c[1], c[0]]));
        layer = L.polygon(coords, {});
        break;

      default:
        console.log('Unsupported feature type: ' + feature.geometry.type);
        return null;
    }

    layer.id = id;

    return layer;
  }

});

